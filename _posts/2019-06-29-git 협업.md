---
layout: post
title:  "Git 협업을 위한 내용"
comments: true
description: "Git 협업, git flow"
author: SeungHyeon Tak
date:   2019-06-29 19:46:11 +0700
categories: [Github]
tags: [Github]
keywords: "Git 협업"
---
### Git 협업(Github 사용도 이해하기)

### Git을 이용한 협업 플로우
<br>
### 1) Centralized Workflow
* Centralized Workflow는 프로젝트에 단일 중앙 저장소를 사용한다.(master)브랜치 하나만 사용됨
(팀 구성원들은 중앙 저장소를 복제하여 로컬 저장소를 만들고, 로컬 저장소에서 변경 내용을 커밋하고 원할때 중앙 저장소와 동기화 한다.)
![1](https://user-images.githubusercontent.com/46446165/60387284-aba8ea00-9adb-11e9-9103-8716dd673451.png)
<br>
![2](https://user-images.githubusercontent.com/46446165/60387286-b499bb80-9adb-11e9-8979-4f25cef3843f.png)
<br>

### 1-1) 충돌 처리
중앙 저장소의 커밋이 기준이된다. 
로컬 저장소의 변경 내용을 push하려할때, 
저장소의 커밋 이력과 충돌한다면 Git은 저장소의 커밋을 보호하기 위해 push를 거부함
※ 이때는 중앙 저장소의 변경 내용을 먼저 로컬 저장소로 가져와서(fetch)자신의 변경 내용을 합치거나(Merge) 재배열(Rebase)해야한다.
Merge나 Rebase도중 중앙저장소의 변경 내역과 자신의 커밋 내역이 충돌한다면, 수작업으로 충돌을 해결해야함
충돌을 해결한 후에는 해당 사항을 새로운 커밋으로 만들어 Merge나 Rebase를 완료하고 중앙 저장소에 push한다.
<br>

### 1-2) 예시 사례
철수와 영희, 두명의 개발자로 구성된 팀이 Centralized Workflow를 이용해 협업하는 과정을 예시들어보겠다.
<br>
* 중앙 저장소 생성
철수나 영희 둘중 한명이 중앙 저장소를 생성한다.
일반적인 협업에서는 GitHub과 같은 온라인 리모트 저장소를 활용한다. (GitHub에 대한 내용이니 GitHub로 만들어서 가정해보겠다.)
<br>
![3](https://user-images.githubusercontent.com/46446165/60387380-0f7fe280-9add-11e9-80ab-9f1ffe54cf1d.png)
<br>
이렇게 생성하면 Git저장소 주소보이는 페이지가 나올것이다.
<br>
* 중앙 저장소 복제
모든 팀 구성원들은 `git clone`명령어로 중앙 저장소를 복제한 로컬 저장소를 만든다.

```
$ git clone 'git 저장소 주소'
```

<br>
* 철수의 작업
철수는 로컬 저장소에서 자신이 맡은 기능을 개발하고 변경 내용을 커밋한다.

```
$ echo '철수의 작업' > work.txt
$ git add work.txt
$ git commit -m "철수 - 작업1 추가"
```

로컬 저장소에 커밋할때는 몇번이고 커밋을 변경하며 내용을 수정해도 상관 없다.
가능하다면 아주 작은 단위로 커밋하여 상세하게 프로젝트 이력을 유지하는 것이 좋다.
<br>

* 영희의 작업
영희도 철수와 마찬가지로 로컬 저장소에서 자신이 맡은 기능을 개발하고 커밋한다.

```
$ echo '영희의 작업' > work.txt
$ git add work.txt
$ git commit -m "영희 - 작업1 추가"
```

<br>
* 철수의 작업 내용 발행
<br>
![4](https://user-images.githubusercontent.com/46446165/60387457-89649b80-9ade-11e9-8bcd-3005f378f79a.png)
<br>
철수는 `git push`명령으로 자신의 로컬 커밋 이력을 중앙저장소에 발행해 다른 팀 구성원과 공유한다.

```
$ git push origin master
```

`origin`은 철수가 중앙 저장소를 복제할 때 자동 생성된 중앙 저장소의 별칭이다!!
master는 현재 push명령을 실행하고 있는 브랜치의 내용을 중앙 저장소인 origin의 master브랜치에 동기화 하겠다는 뜻이다.
<br>
로컬 저장소에서 따로 브랜치를 생성하지 않았기 때문에, 지금은 로컬의 master브랜치 변경 내역을 origin의 master브랜치와 동기화 하게 된다.
※ 여기서 철수와 영희중 아무도 중앙 저장소를 변경하지 않았기 때문에, 철수의 push는 충돌없이 순조롭게 진행된것이다.
<br>

* 영희의 작업 내용 발행
<br>
![5](https://user-images.githubusercontent.com/46446165/60387465-9a151180-9ade-11e9-96c9-b2e16417c926.png)
<br>
철수가 push한 후 영희가 로컬 커밋을 push하면 무슨일이 일어날까?

```
$ git push origin master
```
<br>
![6](https://user-images.githubusercontent.com/46446165/60387485-d0529100-9ade-11e9-9c98-0a2cb5a3419a.png)
<br>
이러한 에러가 뜰것이다

※영희는 중앙 저장소의 최신 커밋 이력을 로컬로 받아온 후, 자신의 로컬 커밋 이력과 통합하고 다시 push해야한다.※
<br>

* 영희의 fetch와 rebase
영희는 (중요)`git fetch`명령을 사용해 중앙 저장소의 변경 이력을 로컬 저장소에 내려받는다.
<br>
![7](https://user-images.githubusercontent.com/46446165/60387504-3d662680-9adf-11e9-8fbf-b333525f8c51.png)
<br>

```
$ git fetch origin
```

fetch명령어를 변경 이력을 저장소에 가져올 뿐, 현재 로컬 이력과 자동으로 합쳐주지 않는다. 이를 `git log`명령어에 옵션을 사용해 알아볼 수 있다.

```
$ git log --oneline --all --graph

(내용이 나타날것이다.)
```

rebase명령을 사용해 중앙 저장소의 커밋 이력을 영희의 커밋 이력 앞에 끼워 넣는다.
<br>
![8](https://user-images.githubusercontent.com/46446165/60387538-a9e12580-9adf-11e9-93df-a5d6d49de201.png)
<br>

```
$ git rebase origin/master
```

철수와 영희 모두 work.txt 라는 파일을 생성했기 때문에, 
Git은 해당 파일의 변경 내역을 자동으로 합쳐주지 못한다. 
이러한 파일의 충돌은 수동으로 해결해야한다.
<br>

* 영희의 충돌 해결
<br>
![1](https://user-images.githubusercontent.com/46446165/60387561-fcbadd00-9adf-11e9-8c3c-1a01ad6a063a.png)
<br>
`git status`명령어를 사용해 어떤 파일에 충돌이 발생했는지 확인해본다.

```
$ git status
(에러 내용)
...
both added: work.txt
...
```

work.txt 파일을 양쪽에서 수정해서 Conflict가 발생했다. 영희는 해당 파일을 적절히 수정하고 해당 내역을 커밋으로 만들어야 함

```
$ vi work.txt

<<<<<< HEAD
철수의 작업
=======
영희의 작업
>>>>>> 영희의 작업 추가
```

`<<<<<<<HEAD`에서 `=========`까지의 내용은 저장소에 원래 존재하던 내용이며, 
`========` 이후 `>>>>>>영희의작업 추가` 사이의 내용은 영희의 작업추가 로컬 커밋의 내용이다
이 파일의 내용을 아래와 같이 수정한다.

```
철수의 작업
영희의 작업
```

이제 변경사항을 Git에 추가하고, `rebase`를 다시 진행한다.

```
$ git add work.txt
$ git rebase --continue
```

이제 `git log`를 사용해 작업 내역을 확인하면 `origin/master`의 뒤에 영희의 커밋 내역이 있는것을 확인 할 수 있다.

```
$ git log
...
영희 작업 추가
...
철수 작업 추가
```

중앙 저장소의 내역을 로컬에 전부 적용하고, 새 커밋을 만들었으니 중앙 저장소에 새 커밋 내역을 푸시한다.

```
$ git push origin master
```

로컬 커밋이 중앙 저장소와 동기화 되었음을 최신 커밋의 상태로 확인가능

```
$ git log
... log 내용 확인 가능
```
<br>

* 다음 단계
Workflow는 git의 특장점인 분산 버전 관리의 이점을 사용할 수는 없지만, git에 익숙하지 않을 때 최소한의 명령어로 협업을 진행해 볼 수 있다.
<br>
* Feature Branch Workflow
Feature Branch Workflow의 핵심은 기능별 브랜치를 만들어 작업하는 것이다.
`master`브랜치는 항상 버그 프리 상태로 유지하며, 병합시 권한을 가진 사용자가 Pull requests를 적용할 수 있다.
<br>

### 2-1) 작동 원리

