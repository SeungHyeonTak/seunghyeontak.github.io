---
layout: post
title:  "Algorithm study 시간복잡도 (Big O)"
comments: true
description: "Big O"
author: SeungHyeon Tak
date:   2020-02-21 01:35:00 +0700
categories: [Algorithm]
tags: [Algorithm]
keywords: "Big O"
---
## Algorithm

### 시간 복잡도

* 알고리즘 복잡도 계산이 필요한 이유
  * 하나의 문제를 푸는 알고리즘은 다양할 수 있다.
  
예를 들어

정수의 절대값 구하기
  * 정수값을 제곱한 값에 다시 `루트 씌우기`
  * 정수가 음수인지 확인해서, `음수일때만` -1 곱하기

다양한 알고리즘 중 어느 알고리즘이 더 좋은지를 분석 하기 위해 복잡도를 정의하고 계산함

* 알고리즘 복잡도 계산 항목
  * 시간복잡도(중요) : 알고리즘 실행 속도
  * 공간복잡도 : 알고리즘이 사용하는 메모리 사이즈 (즉, 변수 선언을 얼마나 했냐에 따라 다르다는 뜻)

> 가장 중요한 시간복잡도를 꼭 이해하고 계산할 수 있어야한다.

알고리즘 시간복잡도의 주요 요소는 `반복문`이다.

왜냐하면 어떻게 구성했는지에 따라서 결정나거나, 입력의 크기가 커지면 커질수 록 반복문이 알고리즘 수행시간을 지배하기 때문이다.

* 알고리즘 성능 표기법
  *  Big-O 표기법
     * 알고리즘 최악의 실행 시간을 표기
     * 가장많이, 일반적으로 사용됨
     * 아무리 최악의 상황이라도, 이정도의 성능을 보장 한다는 의미

시간복잡도에서 우리가 알게 모르게 제일 많이 사용하는 복잡도는 `O(n)`이다.

성능법에 대해 이어서 말하자면

입력 n에 따라 결정되는 시간 복잡도 함수

O(1) < O(log n) < O(n) < O(n log n) < O(n^2) < O(2^n) < O(n!)

위의 순서는 n의 크기에 따라 기하급수적으로 시간 복잡도가 늘어난다는 순서이다.

O(1)이 가장 빠른 순으로 느려진다고 보면 된다.

**(참고) log n의 베이스는 2이다.**

문제를 풀어보면서 이해하자

알고리즘

문제) 1부터 n까지의 합을 구하는 알고리즘을 구하시오.

<details>
<summary>알고리즘 1정답 코드</summary>
<div markdown="1">

```python
total = 0 
n = 100

for i in range(1, n+1):
    total += i

print(total)
```
</div>
</details>

<details>
<summary>알고리즘 2정답 코드</summary>
<div markdown="1">

```python
n = 100

result = int(n*(n+1)/2)
```
</div>
</details>

대부분 알고리즘 1번 식으로 풀었을것이다.

여기서 이 두문제에 대해 시간복잡도를 구해보면

1번 식

입력 n에 따라 반복문을 돌려 덧셈을 n번 하는 식이다.

그러므로 `O(n)` 표기법인걸 알 수 있다.

2번식

n이 1이든 2든 3이든 어떤 수가 들어와도 한번만 돌기 때문에 `O(1)`로 표기 된다.



이렇게 시간 복잡도에서는 반복문이 어떻게 쓰이느냐에 따라 바뀔 수 있는걸 볼 수 있다.

알고리즘을 풀때도 어떤 시간복잡도를 생각하느냐에 따라 달라지는걸 알 수 있었다.
